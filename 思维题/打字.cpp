/*
题目描述
给定一个长度为 n 的二进制字符串 s，以及一台只有两个按钮的打字机：按钮 0 和按钮 1。
一开始，你的手指放在按钮 0 上。
你可以执行以下两种操作：
按下当前手指所在的按钮，这会输入该按钮上的字符。
将手指移动到另一个按钮。如果当前在按钮 0，则移动到按钮 1；如果在按钮 1，则移动到按钮 0。
一个二进制字符串的代价定义为：打出整个字符串所需的最少操作次数。
在开始打字之前，你最多可以反转一次子串 。
更正式地说，你可以选择两个下标 1≤l≤r≤n，将子串 sl…r反转，得到新的字符串：s1s2…sl−1;srsr−1…sl;sr+1…sn
你的任务是：在最多进行一次子串反转的前提下，求所有可能得到的字符串中，打字代价的最小值。
如果字符串 a 可以通过从字符串 b 的开头和结尾删除若干个（可能为 0 个或全部）字符得到，则称 a 是 b 的一个子串。
输入描述
第一行是一个整数 t 表示测试用例数量(1≤t≤10^4)。
每个测试用例包含两行：
第一行一个整数 n(1≤n≤2⋅10^5)——字符串 s 的长度。
第二行是一个二进制字符串 s 长度为 n。
保证所有测试用例中 n 的总和不超过 2⋅10^5。
输出描述
对每个测试用例，输出一个整数 —— 在可做至多一次子串反转之后，得到的字符串的最小打字代价。
*/
#include<bits/stdc++.h>
#define int long long
using namespace std;
void solve()
{
    int n;cin>>n;
    string s;cin>>s;
    int ans=n;
    char now='0';
    for(int i=0;i<n;++i)
    {
        if(now!=s[i])
        {
            now=s[i];
            ans++;
        }
    }
    s='0'+s;
    int a=-1,b=-1,c=-1,d=-1;
    for(int i=1;i<=n;++i)
    {
        if(a!=-1&&b!=-1)break;
        if(s[i]=='1'&&s[i-1]=='0')a=i-1;
        else if(s[i]=='0'&&s[i-1]=='1')b=i-1;
    }
    for(int i=n-1;i>=0;--i)
    {
        if(c!=-1&&d!=-1)continue;
        if(s[i]=='1'&&s[i+1]=='0')c=i;
        else if(s[i]=='0'&&s[i+1]=='1')d=i;
    }
    if(a!=d||b!=c)//有两个01或10
    {
        cout<<ans-2<<'\n';
        return;
    }
    if(s[n]=='0'&&(a!=-1||b!=-1))//最后一个是0，前面有1
    {
        cout<<ans-1<<'\n';
        return;
    }
    cout<<ans<<'\n';
}
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    int t;cin>>t;
    while(t--)solve();
}